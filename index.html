    <!DOCTYPE html>
    <html lang="hu">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <link rel="icon" type="image/x-icon" href="img/csabi.jpg">
        <title>SZRCS Szimulátor</title>
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');
            body { 
                margin: 0; 
                overflow: hidden !important; 
                background-color: #000000;
                font-family: 'Montserrat', Arial, sans-serif;
            }

            canvas { display: block; }
            #score, #debug {
                position: absolute;
                top: 10px;
                left: 10px;
                color: white;
                font-size: 24px;
                font-family: sans-serif;
            }

            #loader {
                position: fixed;
                width: 100%;
                height: 100%;
                background: #000000;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            }

            #loadtext {
                color:white;
            }

            /* Simple spinner */
            .spinner {
                width: 50px;
                height: 50px;
                border: 5px solid #ccc;
                border-top-color: #007bff;
                border-radius: 50%;
                animation: spin 1s linear infinite;
            }

            /* Spinner animation */
            @keyframes spin {
                to {
                    transform: rotate(360deg);
                }
            }

            /* Hide content initially */
            .hidden {
                display: none;
            }

            #scoreForm {
                margin: 0;
                top: 40%;
                width: 30%;
                min-width: 420px;
                height: fit-content;
                display: flex;
                flex-direction: column;
                background-color: #dddddd;
                justify-content: center;
                align-items: center;
                position: absolute;
                left: 50%;
                transform: translate(-50%, -50%);
                border-radius: 10px;
                z-index: 2;
            }

            #scoreboard {
                margin: 0;
                top: 20%;
                width: 30%;
                min-width: 420px;
                height: fit-content;
                display: none;
                flex-direction: column;
                background-color: #dddddd;
                justify-content: center;
                align-items: center;
                position: absolute;
                left: 50%;
                transform: translate(-50%, -50%);
                border-radius: 10px;
                z-index: 2;
            }

            #submit {
                width: 30%;
                margin: 0 auto;
                
            }

            .pointer {
                cursor: pointer;
            }

            input {
                margin: 10px 0;
                padding: 10px;
                border: 1px solid #ccc;
                border-radius: 5px;
                width: 80%;
            }

            button {
                margin: 20px;
                border: 1px solid #ccc;
                border-radius: 5px;
                width: 30%;
                height: 10%;
            }

            h2 {
                font-size: 1.5rem;
                color: #333;
                text-align: center;
                margin-bottom: 10px;
            }

            ul {
                list-style: none;
                padding: 0;
                margin: 0;
                background: #f8f9fa;
                border-radius: 8px;
                box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
                padding: 10px;
                max-width: 300px;
                margin: 0 auto;
            }

            li {
                padding: 10px;
                background: white;
                border: 1px solid #ddd;
                border-radius: 5px;
                margin-bottom: 5px;
                font-size: 1rem;
                font-weight: bold;
                display: flex;
                justify-content: space-between;
            }

            #joystick {
                position: absolute;
                bottom: 20px;
                left: 20px;
                width: 100px;
                height: 100px;
                border-radius: 50%;
                background-color: rgba(100, 100, 100, 0.5);
                display: none; /* Hidden by default */
            }
            #joystick-handle {
                position: absolute;
                width: 50px;
                height: 50px;
                border-radius: 50%;
                background-color: rgba(200, 200, 200, 0.8);
                top: 25px;
                left: 25px;
            }

            #rotateLeft, #rotateRight {
                position: absolute;
                bottom: 20px;
                width: 80px;
                height: 40px;
                background-color: rgba(100, 100, 100, 0.5);
                color: white;
                border: none;
                cursor: pointer;
                font-size: 16px;
                display: none;
            }
            #rotateLeft { right: 120px; }
            #rotateRight { right: 20px; }

            @media (pointer: coarse) { /* Touch devices */
                #joystick {
                    display: block; /* Show the joystick on touch devices */
                }
                #rotateLeft, #rotateRight {
                    display: block;
                }
            }
        </style>
    </head>
    <body>
        <div id="loader">
            <div class="spinner"></div>
            <p id="loadtext">Az ódal betűt, váján'</p>
        </div>
        <div id="scoreboard">
            <p>Betöltés...</p>
        </div>
        <div id="scoreForm">
            <h1 class="center">Töltsd fel a rekordod!</h1>
            <label for="username">Neved:</label>
            <input type="text" id="username" name="username" required><br><br>
            <button id="submit" class="pointer" onclick="sendScore()">Beküldés!</button>
            <p id="nem" class="pointer">Haggyá mán'</p>
        </div>
        <div id="score">Pontok: 0</div>
        <div id="debug" style="margin-top: 20px;"></div>
        <div id="joystick">
            <div id="joystick-handle"></div>
        </div>
        <button id="rotateLeft"><</button>
        <button id="rotateRight">></button>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.155.0/three.min.js"></script>

        <script>
            function loadScoreboard() {
                document.getElementById('scoreboard').style.display = 'flex';
                fetch('getScoreboard.php')
                .then(response => response.json()) // JSON formátumot olvasunk
                .then(data => {
                    if (data.status === "success") {
                        let scoreboardHTML = "<h2>Top sigma épbokájú játékosok:</h2><ul>";
                        data.scores.forEach((entry, index) => {
                            scoreboardHTML += `<li>${index + 1}. ${entry.name} - ${entry.score} pont</li>`;
                        });
                        scoreboardHTML += `</ul><button onclick="document.getElementById('scoreboard').style.display = 'none';">OK</button>`;
                        document.getElementById('scoreboard').innerHTML = scoreboardHTML;
                    } else {
                        document.getElementById('scoreboard').innerHTML = "<p>Hiba a toplista betöltésekor.</p>";
                    }
                })
                .catch(error => {
                    console.error('Hiba a scoreboard lekérésében:', error);
                    document.getElementById('scoreboard').innerHTML = "<p>Bruh. Nem sikerült betölteni a toplistát.</p>";
                });
            }        

        </script>

        <script>
            document.getElementById('nem').addEventListener('click', function() {
                document.getElementById('scoreForm').style.display = 'none';
                loadScoreboard();
            });

            function sendScore() {
                username = document.getElementById('username').value;

                if (!username || isNaN(score)) {
                alert("Hibás adatok!");
                return;
                }

                const formData = new FormData();
                formData.append('username', username);
                formData.append('score', deathScore);

                fetch('scoreboard.php', {
                    method: 'POST',
                    body: formData,
                })
                .then(response => response.json()) // JSON formátumot olvasunk vissza
                .then(data => {
                    alert(data.message); // Az üzenetet alertben jelenítjük meg
                })
                .catch(error => {
                    console.error('Error sending score:', error);
                });
                document.getElementById('scoreForm').style.display = 'none';
                loadScoreboard();
            }
        </script>

        <script>
            // Setup
            const scene = new THREE.Scene();
            let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Texture Loader
            const textureLoader = new THREE.TextureLoader();

            // Player (Cube) with Texture
            const playerTexture = textureLoader.load('img/csabi.jpg'); // Replace with your texture path
            const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
            const playerMaterial = new THREE.MeshBasicMaterial({ map: playerTexture });
            const player = new THREE.Mesh(playerGeometry, playerMaterial);
            scene.add(player);
            player.position.y = 0.5;

            // Target (Sphere) with Texture
            const targetTexture = textureLoader.load('img/labda.jpg'); // Replace with your texture path
            const targetGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const targetMaterial = new THREE.MeshBasicMaterial({ map: targetTexture });
            const target = new THREE.Mesh(targetGeometry, targetMaterial);
            scene.add(target);
            target.position.x = 5;
            target.position.y = 0.5;

            // Ground (Plane)
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            scene.add(ground);
            ground.rotation.x = -Math.PI / 2;

            // Camera setup (Initial position)
            camera.position.z = 5;
            camera.position.y = 2;
            camera.lookAt(player.position);

            const rotateLeftButton = document.getElementById('rotateLeft');
            const rotateRightButton = document.getElementById('rotateRight');
            let rotationDirection = 0; // 0: no rotation, 1: right, -1: left

            const joystick = document.getElementById('joystick');
            const joystickHandle = document.getElementById('joystick-handle');
            let joystickActive = false;
            let joystickOffsetX = 50;
            let joystickOffsetY = 0;
            let joystickX = 0;
            let joystickY = 0;

            joystick.addEventListener('touchstart', (event) => {
                joystickActive = true;
                joystickOffsetX = event.touches[0].clientX - joystickHandle.offsetLeft - joystick.offsetLeft;
                joystickOffsetY = event.touches[0].clientY - joystickHandle.offsetTop - joystick.offsetTop;
            });

            joystick.addEventListener('touchmove', (event) => {
                if (joystickActive) {
                    let x = event.touches[0].clientX - joystickOffsetX - joystick.offsetLeft;
                    let y = event.touches[0].clientY - joystickOffsetY - joystick.offsetTop;
                    const maxDistance = 25;
                    const distance = Math.sqrt(x * x + y * y);
                    if (distance > maxDistance) {
                        x = (x / distance) * maxDistance;
                        y = (y / distance) * maxDistance;
                        x += 25;
                        y += 25;
                    }
                    joystickHandle.style.left = x + 'px';
                    joystickHandle.style.top = y + 'px';

                    joystickX = x / maxDistance;
                    joystickY = y / maxDistance;
                }
            });

            joystick.addEventListener('touchend', () => {
                joystickActive = false;
                joystickHandle.style.left = '25px';
                joystickHandle.style.top = '25px';
                joystickX = 0;
                joystickY = 0;
            });

            const keys = {};
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
            });
            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
            });
            let mouseX = 0;
            document.addEventListener('mousemove', (event) => {
                mouseX = event.clientX;
            });
            let score = 0;
            const scoreElement = document.getElementById('score');

            target_dx = 0;
            target_dy = 0;
            player_dx = 0;
            player_dy = 0;

            let deathScore = 0;
            let mobileRotation = 0;

            // Game Logic (Same as before)
            function update() {
                const speed = 0.1;
                const acceleration = 0.01;
                const friction = 0.99;
                const rotationSpeed = 0.005;
                const mobileRotationSpeed = 0.1;
                rotateLeftButton.addEventListener('touchstart', () => {
                    rotationDirection = -1;
                });
                rotateLeftButton.addEventListener('touchend', () => {
                    rotationDirection = 0;
                });
                rotateLeftButton.addEventListener('mousedown', () => {
                    rotationDirection = -1;
                });
                rotateLeftButton.addEventListener('mouseup', () => {
                    rotationDirection = 0;
                });
                rotateRightButton.addEventListener('touchstart', () => {
                    rotationDirection = 1;
                });
                rotateRightButton.addEventListener('touchend', () => {
                    rotationDirection = 0;
                });
                rotateRightButton.addEventListener('mousedown', () => {
                    rotationDirection = 1;
                });
                rotateRightButton.addEventListener('mouseup', () => {
                    rotationDirection = 0;
                });
                const rotation = (mouseX - window.innerWidth / 2) * rotationSpeed;

                if (navigator.maxTouchPoints > 0) {
                    mobileRotation -= rotationDirection * mobileRotationSpeed;
                    camera.position.x = player.position.x + 5 * Math.sin(mobileRotation);
                    camera.position.z = player.position.z + 5 * Math.cos(mobileRotation);
                } else {
                    camera.position.x = player.position.x + 5 * Math.sin(rotation);
                    camera.position.z = player.position.z + 5 * Math.cos(rotation);
                }
                if (joystickX !== 0 || joystickY !== 0) {
                    // Normalize joystick values to range -1 to 1
                    const normalizedJoystickX = (joystickX - 1);
                    const normalizedJoystickY = -(joystickY - 1);

                    // Get camera's world direction
                    const cameraDirection = new THREE.Vector3();
                    camera.getWorldDirection(cameraDirection);
                    cameraDirection.y = 0; // Keep movement horizontal
                    cameraDirection.normalize();

                    // Calculate movement direction relative to camera
                    const moveDirection = new THREE.Vector3(normalizedJoystickX, 0, normalizedJoystickY);

                    // Calculate right vector
                    const rightVector = new THREE.Vector3();
                    rightVector.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0));
                    rightVector.normalize();

                    // Calculate final movement vector
                    const finalMoveDirection = new THREE.Vector3();
                    finalMoveDirection.addVectors(
                        cameraDirection.clone().multiplyScalar(moveDirection.z), // Forward/backward
                        rightVector.clone().multiplyScalar(moveDirection.x)  // Left/right
                    );
                    finalMoveDirection.normalize();

                    // Apply joystick movement to velocity
                    player_dx += finalMoveDirection.x * speed / 10;
                    player_dy += finalMoveDirection.z * speed / 10;

                }

                camera.lookAt(player.position);
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();

                const strafeDirection = new THREE.Vector3();
                strafeDirection.crossVectors(direction, camera.up);
                strafeDirection.normalize();

                if (keys['ArrowUp'] || keys['KeyW']) {
                    player_dx += direction.x * acceleration;
                    player_dy += direction.z * acceleration;
                }
                if (keys['ArrowDown'] || keys['KeyS']) {
                    player_dx -= direction.x * acceleration;
                    player_dy -= direction.z * acceleration;
                }
                if (keys['ArrowRight'] || keys['KeyD']) {
                    player_dx += strafeDirection.x * acceleration;
                    player_dy += strafeDirection.z * acceleration;
                }
                if (keys['ArrowLeft'] || keys['KeyA']) {
                    player_dx -= strafeDirection.x * acceleration;
                    player_dy -= strafeDirection.z * acceleration;
                }

                // Apply friction
                player_dx *= friction;
                player_dy *= friction;

                // Apply velocity to player position
                player.position.x += player_dx;
                player.position.z += player_dy;
                const distance = player.position.distanceTo(target.position);
                if (score > 20) {
                    scoreElement.textContent = 'Pontok: ' + score + " (nagyon profi vagy)";
                } else {
                    scoreElement.textContent = 'Pontok: ' + score;
                }
                if (distance < 1) {
                    score++;
                    target.position.x = (Math.random() - 0.5) * 10;
                    target.position.z = (Math.random() - 0.5) * 10;
                }

                if (target_dx > 1) {
                    target_dx -= Math.random() / 100;
                } else if (target_dx < -1) {
                    target_dx += Math.random() / 100;
                } else {
                    target_dx += Math.random() - 0.5 / 100;
                }

                if (target_dy > 1) {
                    target_dy -= Math.random() / 100;
                } else if (target_dy < -1) {
                    target_dy += Math.random() / 100;
                } else {
                    target_dy += Math.random() - 0.5 / 100;
                }

                if (target.position.x > 10 && target_dx > 0) {
                    target_dx = -target_dx;
                }
                if (target.position.x < -10 && target_dx < 0) {
                    target_dx = -target_dx;
                }
                if (target.position.z > 10 && target_dy > 0) {
                    target_dy = -target_dy;
                }
                if (target.position.z < -10 && target_dy < 0) {
                    target_dy = -target_dy;
                }

                target.position.x += target_dx / 10;
                target.position.z += target_dy / 10;

                if (Math.abs(player.position.x) > 10.5 || Math.abs(player.position.z) > 10.5 || player.position.y < 0.5) {
                    player.position.y -= 0.1;
                    camera.position.y += 0.1;
                }
                if (player.position.y < -20) {
                    alert("Leestél a lépcsőn és kitörted a bokád");
                    if (deathScore < score) {
                        document.getElementById('scoreForm').style.display = 'flex';
                    } else {
                        loadScoreboard()
                    }
                    player_dx = player_dy = player.position.x = player.position.z = 0;
                    player.position.y = 0.5
                    camera.position.y = 2;
                    deathScore = score;
                    score = 0;
                }
            }

            // Animation Loop (Same as before)
            function animate() {
                requestAnimationFrame(animate);
                update();
                renderer.render(scene, camera);
            }

            window.addEventListener("load", function () {
                const loader = document.getElementById("loader");
                document.getElementById('scoreForm').style.display = 'none';

                loader.style.display = "none";
                animate();
            });

            window.addEventListener("resize", function () {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            })
        </script>
    </body>
    </html>